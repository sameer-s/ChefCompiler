PARSER_BEGIN(Parser)
package parser;
public class Parser {
    public static void main(String[] args) throws Throwable {
        Parser parser = new Parser(new java.io.FileInputStream("HelloWorld.chef"));
        Parser.Start();
    }

}
PARSER_END(Parser)

// Assumptions when unspecified in the main Chef specification
// Tabs are treated the same as spaces
// The comments paragraph does not necessarily need to end with a full stop
// Spaces are not permitted before mandatory fullstops

// Other defined for this state: NUMBER, CHAR
<INGREDIENTS_STATE> TOKEN: {
    <INGREDIENTS: "Ingredients"> |
    <MEASURE_TYPE: "heaped" | "level"> |
    <DRY_MEASURE: "g" | "kg" | "pinch"("es")?> |
    <WET_MEASURE: "ml" | "l" | "dash"("es")?> |
    <UNSPECIFIED_MEASURE: "cup" | "cups" | "teaspoon"("s")? | "tablespoon"("s")? >
}

<COOKING_TIME_STATE> TOKEN: {
    < COOKING_TIME: "Cooking" (<SPACE>)+ "time:"> |
    < TIME_UNIT: "hour"("s")? | "minute"("s")? >
}

<OVEN_TEMP_STATE> TOKEN: {
    < PREHEAT: "Pre-heat" (<SPACE>)+ "oven" (<SPACE>)+ "to" > |
    < TEMP_UNIT: "degrees" (<SPACE>)+ "Celsius" > |
    < GAS_MARK: "(gas" (<SPACE>)+ "mark" > |
    < CLOSE_PAREN: ")" >
}

<METHOD_STATE> TOKEN: {
    < METHOD: "Method." > |
    < TAKE: "Take" > |
    < PUT: "Put" > |

    < FROM: "from" > |
    < INTO: "into" > |
    < TO: "to" > |
    < THE: "the" > |

    < FRIDGE: "refrigerator" > |
    < MIXING_BOWL: "mixing" (<SPACE>)+ "bowl" >
}

<INGREDIENTS_STATE, COOKING_TIME_STATE, OVEN_TEMP_STATE> TOKEN: {
    < NUMBER: (["0"-"9"])+ | (["0"-"9"])*"."(["0"-"9"])+ >
}
<DEFAULT, COOKING_TIME_STATE, OVEN_TEMP_STATE> TOKEN: {
    < FULLSTOP: "." >
}
<DEFAULT, COMMENTS_STATE, METHOD_STATE> TOKEN: {
    < CHAR: ~["\n", "\r", " ", "\t"] >
}
<*> TOKEN: {
    // When possible, spaces are grabbed as a part of EOL tokens as those spaces are never useful and it simplifies the grammar
    < EOL: (<SPACE>)* ("\r\n" | "\r" | "\n") (<SPACE>)* > |
    < SPACE: (" " | "\t") >
}
// These "generic" tokens should be matched last, thus they are at the end

void Start() :
{ System.out.println("Warning: did you regenerate parser?"); }
{
    // Recipe Title
    (<SPACE>)* (<CHAR>)+ ((<SPACE>)+ (<CHAR>)+)* <FULLSTOP>
    BlankLine()

    // Comments
    { ParserTokenManager.SwitchTo(COMMENTS_STATE); }
    ((<CHAR> | <SPACE>)+ BlankLine())?

    // Ingredients
    { ParserTokenManager.SwitchTo(INGREDIENTS_STATE); }
    {System.out.println(1);}
    <INGREDIENTS> {System.out.println(2);} <EOL>
    {System.out.println(3);}
    (
        (
            (<NUMBER> (<SPACE>)+)?
            (LOOKAHEAD(IngredientMeasureToken()) IngredientMeasureToken())?
            IngredientNameToken() (IngredientNameToken() | <SPACE>)* <EOL>
        )*
        (<EOL>)+ // Match second part of blank line
    )?

    // Cooking Time
    { ParserTokenManager.SwitchTo(COOKING_TIME_STATE); }
    (
        <COOKING_TIME> (<SPACE>)+
        <NUMBER>
        ((<SPACE>)+ <TIME_UNIT>)?
        <FULLSTOP> (<SPACE>)*
        BlankLine()
    )?

    // Oven Temperature
    { ParserTokenManager.SwitchTo(OVEN_TEMP_STATE); }
    (
        <PREHEAT> (<SPACE>)+ <NUMBER> (<SPACE>)+ <TEMP_UNIT>
        ((<SPACE>)+ <GAS_MARK> (<SPACE>)+ <NUMBER> <CLOSE_PAREN>)?
        <FULLSTOP> (<SPACE>)*
        BlankLine()
    )?

    { ParserTokenManager.SwitchTo(METHOD_STATE); }
    {

    }

//    (<EOL>)*
    <EOF>
}

// Matches at least one blank line (two newlines)
void BlankLine():
{}
{
    <EOL> (<EOL>)+
}


void IngredientMeasureToken():
{}
{
<   MEASURE_TYPE> (<SPACE>)+ <UNSPECIFIED_MEASURE> | <DRY_MEASURE> | <WET_MEASURE> (<SPACE>)+
}

// Just match any token, it doesn't really matter - reserved keywords should not be relevant
// Not matching <INGREDIENTS> though because fullstops should not be in ingredient names
void IngredientNameToken():
{}
{
    <CHAR>  | <MEASURE_TYPE> | <DRY_MEASURE> | <WET_MEASURE> | <UNSPECIFIED_MEASURE>
}
